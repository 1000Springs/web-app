<div id ="collapsibleTreeWrapper" style="width: 1000px; height: 700px">
	<div id="collapsibleTreeChart" style="width: 680px; float: left;"></div>
	<div id="collapsibleTreeInfoPanel" style="float: left; padding: 10px; width: 300px;">
	    <div id="collapsibleTreeDetailWrapper" style="width: 290px; height: 320px; margin-top: 15px">	
	        <h3 id="collapsibleTreeTaxonDetailsName"></h3>
	    	<div id="collapsibleTreeAjaxWaiting"><img src="{{ url_for('static', filename='img/ajax-waiting.gif') }}">Loading summary, please wait </div>
			<div id="collapsibleTreeDetail"></div>
		</div>		
	    <div id="collapsibleTreeTaxonomy">
	    	<table style="width: 290px;">
	    	    <tr><th></th><th style="width: 40px"></th><th style="width: 80px"></th></tr>
	    		<tr><td><div class="domainColour domainName taxon"></div></td><td><div class="domainBackColour taxaSwatch"></div></td><td>Domain</td></tr>
	    		<tr><td><div class="phylumColour phylumName taxon"></div></td><td><div class="phylumBackColour taxaSwatch"></div></td><td>Phylum</td></tr>
	    		<tr><td><div class="classColour className taxon"></div></td><td><div class="classBackColour taxaSwatch"></div></td><td>Class</td></tr>
	    		<tr><td><div class="orderColour orderName taxon"></div></td><td><div class="orderBackColour taxaSwatch"></div></td><td>Order</td></tr>
	    		<tr><td><div class="familyColour familyName taxon"></div></td><td><div class="familyBackColour taxaSwatch"></div></td><td>Family</td></tr>
	    		<tr><td><div class="genusColour genusName taxon"></div></td><td><div class="genusBackColour taxaSwatch"></div></td><td>Genus</td></tr>
	    		<tr><td><div class="speciesColour speciesName taxon"></div></td><td><div class="speciesBackColour taxaSwatch"></div></td><td>Species</td></tr>
	    	</table>
	    </div>

	</div>
</div>

<script type="text/javascript">

var treeData = {{taxJson|safe}};
var w = 680,
    h = 680,
    node,
    link,
    root;

var force = d3.layout.force()
    .on("tick", tick)
    .charge(function(d) {return d.depth * -10})
    .gravity(0.1)
    .linkDistance(25)
    .size([w, h]);

var vis = d3.select("#collapsibleTreeChart").insert("svg")
    .attr("width", w)
    .attr("height", h);

root = treeData;
root.fixed = true;
root.x = w / 2;
root.y = h / 2;
window.maxCollapsibleTreeDepth = 8;

update(true, window.maxCollapsibleTreeDepth);

$('#collapsibleTreeTaxonomy .taxaSwatch').click(function(){
	var row =  $(this).closest('tr').index();
	window.maxCollapsibleTreeDepth = row + 1;
	update(false, window.maxCollapsibleTreeDepth);
});

function update(positionNodes, maxDepth) {
	
	var nodes = flatten(root, maxDepth);
	var links = d3.layout.tree().links(nodes);
	
	if (positionNodes) {
		nodes.forEach(function(d, i) {
		  d.x = w/2 + i;
		  d.y = h/2 + 100 * d.depth;
		});	
	}

	// Restart the force layout.
	force
	    .nodes(nodes)
	    .links(links)
	    .start();

	// Update the links…
	link = vis.selectAll("line.link")
	      .data(links, function(d) { return d.target.id; });
	
	// Enter any new links.
	link.enter().insert("svg:line", ".node")
	    .attr("class", function(d) { return (d.source.depth == 1) ? "root link" : "link";})
	    .attr("x1", function(d) { return d.source.x; })
	    .attr("y1", function(d) { return d.source.y; })
	    .attr("x2", function(d) { return d.target.x; })
	    .attr("y2", function(d) { return d.target.y; });
	
	// Exit any old links.
	link.exit().remove();
	
	// Update the nodes…
	node = vis.selectAll("circle.node")
	    .data(nodes, function(d) { return d.id; })
	    .style("fill", function (d) {
	    	var colour = getNodeColour(d);
	    	return colour;
	     });
	
	
	node.transition()
	    .attr("r", function(d) {
	    	return d.children ? 6 : 10 + (d.size / 750);
	    });
	
	// Enter any new nodes.
	node.enter().append("svg:circle")
	 	.attr("class", function(d) { return (d.depth == 1) ? "root node" : "node";})
	    .attr("cx", function(d) { return d.x; })
	    .attr("cy", function(d) { return d.y; })
	    .attr("r", function(d) {
	    	return d.children ? 6 : 10 + (d.size / 1000); 
	    })
	    .style("fill", function (d) {return getNodeColour(d)})
	    .on("click", click)
	    .call(force.drag);
	
	// Exit any old nodes.
	node.exit().remove();
}

function tick() {
  link.attr("x1", function(d) { return d.source.x; })
      .attr("y1", function(d) { return d.source.y; })
      .attr("x2", function(d) { return d.target.x; })
      .attr("y2", function(d) { return d.target.y; });

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

function getNodeColour(d) {
	
	var colour;
	if (typeof d.taxa !== 'undefined') {
		if (d.selectedBranch) {
			colour = $('.' + d.taxa + 'Colour').css('color');
		} else {
			colour = $('.' + d.taxa + 'BackColour').css('background-color');
		}
	} else {
		colour = "#000000"
	}
	
	return colour;
}

// Toggle children on click.
function click(d) {
	if (d.name != 'root') {
		clearSelectedTaxonomy();
		setSelectedTaxonomy(d);
		populateDetailBox(d.name);
		
		if (d.children) {
		  d._children = d.children;
		  d.children = null;
		} else {
		  d.children = d._children;
		  d._children = null;
		}
		update(false);
	}
}

function clearSelectedTaxonomy() {
	$("#collapsibleTreeTaxonomy .taxon").text("").attr("title", "");
	d3.selectAll('.selectedBranch').classed('selectedBranch', false);
	d3.selectAll('.node').each(function(node) { node.selectedBranch=false;});
}

function setSelectedTaxonomy(node) {
	
	if (node.name != "root") {
		$("#collapsibleTreeTaxonomy ." + node.taxa + "Name").text(node.name).attr("title", node.name);
		node.selectedBranch = true;
		setSelectedTaxonomy(getParentNode(node, true));
	}
}

function getParentNode(childNode, highlightLink) {
	var linkToParent = d3.selectAll('.link').filter(function(node){
		return node.target.id == childNode.id;
	});
	
	if (highlightLink && linkToParent.attr("class").indexOf("root") < 0) {
		linkToParent.attr("class", "link selectedBranch");
	}
	
	var parentNode = linkToParent[0][0].__data__.source;
	return parentNode;
}

function populateDetailBox(taxon) {
	
	$('#collapsibleTreeTaxonDetailsName').text(taxon);
	var firstSlash = taxon.indexOf('/');
	if (firstSlash >= 0) {
		taxon = taxon.substring(0, firstSlash);
	}
	$('#collapsibleTreeDetail').fadeOut(function(){
		$('#collapsibleTreeAjaxWaiting').fadeIn(function(){
			$.get('/taxon/'+taxon)  
			  .done(function(data){
				$('#collapsibleTreeAjaxWaiting').fadeOut(function(){
					$('#collapsibleTreeDetail').html(data);		
					$('#collapsibleTreeDetail').fadeIn();
				});
			  })
			  .fail(function() {
				$('#collapsibleTreeAjaxWaiting').fadeOut(function(){	
					$('#collapsibleTreeDetail').html('<h4 class="taxonDetailsError">Unable to load summary</h4>');
					$('#collapsibleTreeDetail').fadeIn();
				});
			  });			
		});		
	});
}


/*
 * Returns a list of all nodes under the root, excluding nodes
 * that have been collapsed by the user or are outside the
 * maximum depth (taxonomy level) selected by the user.
 */
function flatten(root, maxDepth) {
	var nodes = [], i = 0;
	
	function recurse(node, depth) {
		var children = [];
		if (node.children) {
			children = node.children;
		} else if (node._children) {
			children = node._children;
		}
		
		if (node._children && typeof maxDepth !== 'undefined') {
			node.children = node._children;
			node._children = null;
		}
		if (node.children) {
			node.size = node.children.reduce(function(p, v) { return p + recurse(v, depth + 1); }, 0);
		} 
		if (!node.id) node.id = ++i;
		node.depth = depth;
		if (typeof maxDepth !== 'undefined' && depth >= maxDepth) {
			node._children = node.children;
			node.children = null;	
		} 

		if (typeof maxDepth === 'undefined' || depth <= maxDepth) {
			nodes.push(node);		
		}
	
		return node.size;
	}
	
	root.size = recurse(root, 1);
	return nodes;
}
</script>

